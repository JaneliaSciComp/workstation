<!DOCTYPE html>
<html>
<head>
    <title>jacs webgl state viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background: rgba(0,0,0,0.0);
            color:#fff;
            padding:0;
            margin:0;
            overflow:hidden;
            font-family: arial;
            text-align:center;
        }
        h1 { }
        a { color:skyblue; text-decoration:none }

        #d { position:absolute; width: 100%; text-align:center; margin:1em 0 -4.5em 0; z-index:1000; }

        .wrap { margin:0.5em 0 0 0 }
        button { font-family:Georgia; border:0; background:#000; color:#fff; padding:0.2em 0.5em; cursor:pointer; border-radius:3px; }
        button:hover { background:#333 }

        #state_summary { font-family: arial; font-size:1em; text-align:left; background: rgba(60, 60, 60, 0.5); color: rgb(180,180,180); position:fixed; left:0; z-index:10000; bottom:0px; }

    </style>
</head>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<body>

<div id="container"></div>

<script src="js/vendor/threejs/three.js"></script>
<script src="js/vendor/threejs/controls/TrackballControls.js"></script>
<script src="js/vendor/threejs/libs/stats.min.js"></script>

<div ng-app="myApp" ng-controller="myCtrl">

    <p><span ng-bind="serverUrl"/></p>

    <!--<div ng-show="isMode('initialize')">-->
        <!--<h1>Loading...</h1>-->
    <!--</div>-->

    <!--<button ng-click="modeStateSummary()">State Summary</button>-->

    <!--<button ng-click="getCurrentServices()">Current Services</button>-->

    <div ng-show="isMode('stateSummary')">
        <span id="state_summary">
            <table>
                <tr><td>Update: {{stateCount}}</td></tr>
                <tr><td>Created: {{stateSummary.createdCountString}}</td></tr>
                <tr><td>Submitted: {{stateSummary.submittedCountString}}</td></tr>
                <tr><td>Queued: {{stateSummary.queuedCountString}}</td></tr>
                <tr><td>Running: {{stateSummary.runningCountString}}</td></tr>
                <tr><td>Waiting: {{stateSummary.waitingCountString}}</td></tr>
                <tr><td>Canceled: {{stateSummary.canceledCountString}}</td></tr>
                <tr><td>Error: {{stateSummary.errorCountString}}</td></tr>
                <tr><td>Successful: {{stateSummary.successfulCountString}}</td></tr>
            </table>
        </span>
    </div>

    <!--<div ng-show="isMode('currentServices')">-->
        <!--<h1>Current Services {{stateCount}}</h1>-->
        <!--<p>count={{currentServices.length}}</p>-->
        <!--<table>-->
            <!--<tr ng-repeat="x in currentServices | orderBy:'id'">-->
                <!--<td>{{x.id}}</td>-->
                <!--<td>{{x.name}}</td>-->
                <!--<td>{{x.jacsServiceClassName}}</td>-->
                <!--<td>{{x.owner}}</td>-->
                <!--<td>{{x.rootServiceId}}</td>-->
                <!--<td>{{x.parentServiceId}}</td>-->
                <!--<td>{{x.state}}</td>-->
                <!--<td><button ng-click="getEventsForService(x)">Event History</button></form></td>-->
            <!--</tr>-->
        <!--</table>-->
    <!--</div>-->

    <!--<div ng-show="isMode('eventsForService')">-->
        <!--<h1>Event History</h1>-->
        <!--<table>-->
            <!--<tr ng-repeat="x in eventsForService | orderBy:'timestamp'">-->
                <!--<td>{{x.timestamp}}</td>-->
                <!--<td>{{x.type}}</td>-->
                <!--<td>{{x.value}}</td>-->
            <!--</tr>-->
        <!--</table>-->
    <!--</div>-->

</div>

<script>

    // DESIGN OF 3D SERVICE STATE RENDERING
    //
    // Initially, we will poll for the complete "currentServices" state of the JACS system. Later, this will need
    // to be an incremental polling for states which have changed (i.e., had events) within a certain time bounds.
    //
    // The two main mechanisms that need to be implemented are:
    //
    // (1) The ongoing maintenance of currentServices state in a client-side model
    //
    // (2) The ongoing rendering of this state (e.g., keep the camera at 0 but move everything backward in time).
    //
    //  I. CURRENT SERVICES STATE
    //
    //  (a) The client model for current services state will consist of a Map of object.
    //
    //  (b) Each object in the service Map will be inserted with a key for the services' instance id
    //
    //  (c) The service map object contains:
    //        (c.1) the geometric object rendered for this service
    //        (c.2) an up-to-date copy of the state of the service, including a list of events
    //
    // NOTE: only new events will be added to the model, although in theory with the initial version all could
    //       be replaced at each polling cycle.
    //
    // The operational question is, how does the rendering system know which action to take when the model is
    // updated?
    //
    // To answer, when the new events (or all events, as with the initial system) are processed during a polling update,
    // a "renderingOperation" flag is set a Map dedicated to specifying the updates required on the current step.
    // We will call this map the serviceUpdateMap. For services which need to be added, this map will contain the
    // required service metadata. The serviceUpdateObject will contain (a) renderingOperationFlag, (b) a reference to
    // the updated service information.
    //

    var container, stats;
    var camera, controls, scene, renderer;
    var pickingData = [], pickingTexture, pickingScene;
    var objects = [];
    var highlightBox;

    var mouse = new THREE.Vector2();
    var offset = new THREE.Vector3(10, 10, 10);

    // We want to compare the currentServices polling result
    // with the previous list of ids, and then populate the
    // new and removed ids, which we can then use to add or
    // remove geometry objects from the scene.
    // NOTE: after we get this working, we should make the
    // polling more efficient by using the checkpoint API
    // rather than getting all currentServices each time.

    var serviceModel = new Map();
    var serviceUpdates = new Map();

    initThreeJs();
    animateThreeJs();

    var defaultMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors, shininess: 0 });

    function applyVertexColors(g,c) {
        g.faces.forEach(function(f) {
            var n = (f instanceof THREE.Face3) ? 3 : 4;
            for (var j=0;j<n;j++) {
                f.vertexColors[j]=c;
            }
        });
    }

    // based on 'interactive / cubes / gpu' WebGL example
    function initThreeJs() {
        container=document.getElementById("container");
//        camera=new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera=new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1.0, 1000);
        camera.position.z=1000;

        renderer=new THREE.WebGLRenderer( { antalias: true });
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects=false;
        container.appendChild(renderer.domElement);

        stats = new Stats();
        container.appendChild(stats.dom);

        renderer.domElement.addEventListener('mousemove', onMouseMove);

        controls = new THREE.TrackballControls(camera, renderer.domElement);
//        controls.rotateSpeed = 1.0;
        controls.rotateSpeed = 10.0;
//        controls.zoomSpeed = 1.2;
        controls.zoomSpeed = 12.0;
//        controls.panSpeed = 0.8;
        controls.panSpeed = 8.0;

        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;

//        controls.dynamicDampingFactor = 0.3;
        controls.dynamicDampingFactor = 3.0;

        scene = new THREE.Scene();

        pickingScene = new THREE.Scene();
        pickingTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        pickingTexture.texture.minFilter = THREE.LinearFilter;

        scene.add(new THREE.AmbientLight(0x555555));
        var light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light);

        var geometry = new THREE.Geometry();
        var pickingGeometry = new THREE.Geometry();
        var pickingMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );

        var geom = new THREE.BoxGeometry(1,1,1);
        var color = new THREE.Color(0x005500);
        var pickingColor = new THREE.Color();

        var matrix=new THREE.Matrix4();
        var quaternion= new THREE.Quaternion();

        // We want this to be updated every time the number of services changes - in this original version,
        // it is presumably only called during setup
        for (var i = 0; i < 1; i++) {
            var position = new THREE.Vector3();
            position.x = Math.random() * 10000 - 5000;
            position.y = Math.random() * 6000 - 3000;
            position.z = Math.random() * 8000 - 4000;

            var rotation = new THREE.Euler();
            rotation.x = Math.random() * 2 * Math.PI;
            rotation.y = Math.random() * 2 * Math.PI;
            rotation.z = Math.random() * 2 * Math.PI;

            var scale = new THREE.Vector3();
            scale.x = 300;
            scale.y = 300;
            scale.z = 300;

            quaternion.setFromEuler(rotation, false);
            matrix.compose(position, quaternion, scale);

//            applyVertexColors(geom, color.setHex(Math.random() * 0xffffff));
            applyVertexColors(geom, color);
            geometry.merge(geom, matrix);

            applyVertexColors(geom, pickingColor.setHex(i));
            pickingGeometry.merge(geom, matrix);

            pickingData[i] = {position: position, rotation: rotation, scale: scale};
        }

        var drawnObject = new THREE.Mesh(geometry, defaultMaterial);
        scene.add(drawnObject);

        pickingScene.add(new THREE.Mesh(pickingGeometry, pickingMaterial));
        highlightBox = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshLambertMaterial( { color: 0xffff00 }));
        scene.add(highlightBox);

    }

    function onMouseMove(e) {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    }

    function animateThreeJs() {
        requestAnimationFrame(animateThreeJs);
        render();
        stats.update();
    }

    function pick() {
        renderer.render(pickingScene, camera, pickingTexture);
        var pixelBuffer = new Uint8Array(4);
        renderer.readRenderTargetPixels(pickingTexture, mouse.x, pickingTexture.height-mouse.y, 1, 1, pixelBuffer);
        var id = (pixelBuffer[0] << 16) | (pixelBuffer[1] << 8) | (pixelBuffer[2]);
        var data = pickingData[id];

        if (data) {
            if (data.position && data.rotation && data.scale) {
                highlightBox.position.copy(data.position);
                highlightBox.rotation.copy(data.rotation);
                highlightBox.scale.copy(data.scale).add(offset);
                highlightBox.visible=true;
            }
        } else {
            highlightBox.visible=false;
        }
    }

    function render() {
        controls.update();
        pick();
        renderer.render(scene, camera);
    }

    function determineServiceUpdates() {
        // PHASE I: determine updates
        //
        // Iterate through currentServices and populate serviceUpdates()
        serviceUpdates.clear();

        var geometry = new THREE.Geometry();
        var geom = new THREE.BoxGeometry(1,1,1);
        var color = new THREE.Color();
        var matrix=new THREE.Matrix4();
        var quaternion= new THREE.Quaternion();

        var position = new THREE.Vector3();
        position.x = Math.random() * 10000 - 5000;
        position.y = Math.random() * 6000 - 3000;
        position.z = Math.random() * 8000 - 4000;

        var rotation = new THREE.Euler();
        rotation.x = Math.random() * 2 * Math.PI;
        rotation.y = Math.random() * 2 * Math.PI;
        rotation.z = Math.random() * 2 * Math.PI;

        var scale = new THREE.Vector3();
        scale.x = 100;
        scale.y = 100;
        scale.z = 100;

        quaternion.setFromEuler(rotation, false);
        matrix.compose(position, quaternion, scale);

        applyVertexColors(geom, color.setHex(0x00ff00));
        geometry.merge(geom, matrix);

        for (var s=0;s<$scope.currentServices.length;s++) {
            var service=$scope.currentServices[s];
            serviceUpdates.set(service.id, s);

            var position = new THREE.Vector3();
            position.x = Math.random() * 10000 - 5000;
            position.y = Math.random() * 6000 - 3000;
            position.z = Math.random() * 8000 - 4000;

            var rotation = new THREE.Euler();
            rotation.x = Math.random() * 2 * Math.PI;
            rotation.y = Math.random() * 2 * Math.PI;
            rotation.z = Math.random() * 2 * Math.PI;

            var scale = new THREE.Vector3();
            scale.x = 100;
            scale.y = 100;
            scale.z = 100;

            quaternion.setFromEuler(rotation, false);
            matrix.compose(position, quaternion, scale);

            applyVertexColors(geom, color.setHex(0x0000ff));
            geometry.merge(geom, matrix);

        }
        var drawnObject = new THREE.Mesh(geometry, defaultMaterial);
        scene.add(drawnObject);
    }

    function updateServiceModel() {

    }

    var app = angular.module('myApp', []);

    app.controller('myCtrl', function($scope, $http, $location, $interval) {

        $scope.serverUrl = "http://" + $location.host() + ":" + $location.port();

        //  $scope.serverUrl="http://h01u03.int.janelia.org:8180";

        $scope.mode="initialize";

        $scope.isMode = function(m) {
            if ($scope.mode == m) {
                return true;
            }
            return false;
        }

        $scope.switchToMode = function(m) {
            $scope.mode=m;
        }

        $scope.stateCount=0;
        $scope.retrieveOn=false;

        $scope.modeStateSummary = function () {
            $scope.retrieveOn=true;
            $scope.mode="stateSummary";
        }

        $scope.getStateSummary = function() {
            if ($scope.retrieveOn==true) {
                $scope.stateCount = $scope.stateCount + 1;
                $http.get($scope.serverUrl + "/rest-v1/jacsv2/stateSummary")
                    .then(function (response) {
                        $scope.stateSummary = response.data;
                    });
            }
        }

        $scope.threeJsTest = function() {

            var geometry = new THREE.Geometry();
            var geom = new THREE.BoxGeometry(1,1,1);
            var color = new THREE.Color();
            var matrix=new THREE.Matrix4();
            var quaternion= new THREE.Quaternion();

            var position = new THREE.Vector3();
            position.x = Math.random() * 10000 - 5000;
            position.y = Math.random() * 6000 - 3000;
            position.z = Math.random() * 8000 - 4000;

            var rotation = new THREE.Euler();
            rotation.x = Math.random() * 2 * Math.PI;
            rotation.y = Math.random() * 2 * Math.PI;
            rotation.z = Math.random() * 2 * Math.PI;

            var scale = new THREE.Vector3();
            scale.x = 300;
            scale.y = 300;
            scale.z = 300;

            quaternion.setFromEuler(rotation, false);
            matrix.compose(position, quaternion, scale);

            //applyVertexColors(geom, color.setHex(0xff0000));

            color.setHex(0xff0000);

            geom.faces.forEach(function(f) {
                var n = (f instanceof THREE.Face3) ? 3 : 4;
                for (var j=0;j<n;j++) {
                    f.vertexColors[j]=color;
                }
            });

            geometry.merge(geom, matrix);

            var drawnObject = new THREE.Mesh(geometry, defaultMaterial);
            scene.add(drawnObject);
        }

        $scope.getCurrentServices = function() {
            $http.get($scope.serverUrl+"/rest-v1/jacsv2/currentServices")
                .then(function(response) {
                    $scope.currentServices = response.data;
                    $scope.retrieveOn=false;
                    $scope.mode="currentServices";
                    $scope.threeJsTest();
                });
        }

        $scope.getEventsForService = function(x) {
            $scope.eventsForService=x.events;
            $scope.retrieveOn=false;
            $scope.mode="eventsForService";
        }

        var stateSummaryIntervalFunction;
        stateSummaryIntervalFunction=$interval( $scope.getStateSummary, 5000);

        var currentServicesIntervalFunction;
        stateSummaryIntervalFunction=$interval( $scope.getCurrentServices, 5000);

        $scope.modeStateSummary();

    });
</script>

</body>
</html>
