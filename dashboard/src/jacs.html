<!DOCTYPE html>
<html>
<head>
    <title>jacs webgl state viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
<body>

<div id="container"></div>

<script src="js/vendor/threejs/three.js"></script>
<script src="js/vendor/threejs/controls/TrackballControls.js"></script>
<script src="js/vendor/threejs/libs/stats.min.js"></script>

<div ng-app="myApp" ng-controller="myCtrl">

    <p><span ng-bind="serverUrl"/></p>

    <div ng-show="isMode('initialize')">
        <h1>Loading...</h1>
    </div>

    <button ng-click="modeStateSummary()">State Summary</button>

    <button ng-click="getCurrentServices()">Current Services</button>

    <div ng-show="isMode('stateSummary')">
        <h1>State Summary {{stateCount}}</h1>
        <table>
            <tr>Created: {{stateSummary.createdCountString}}</tr>
            <tr>Submitted: {{stateSummary.submittedCountString}}</tr>
            <tr>Queued: {{stateSummary.queuedCountString}}</tr>
            <tr>Running: {{stateSummary.runningCountString}}</tr>
            <tr>Waiting: {{stateSummary.waitingCountString}}</tr>
            <tr>Canceled: {{stateSummary.canceledCountString}}</tr>
            <tr>Error: {{stateSummary.errorCountString}}</tr>
            <tr>Successful: {{stateSummary.successfulCountString}}</tr>
        </table>
    </div>

    <div ng-show="isMode('currentServices')">
        <h1>Current Services {{stateCount}}</h1>
        <p>count={{currentServices.length}}</p>
        <table>
            <tr ng-repeat="x in currentServices | orderBy:'id'">
                <td>{{x.id}}</td>
                <td>{{x.name}}</td>
                <td>{{x.jacsServiceClassName}}</td>
                <td>{{x.owner}}</td>
                <td>{{x.rootServiceId}}</td>
                <td>{{x.parentServiceId}}</td>
                <td>{{x.state}}</td>
                <td><button ng-click="getEventsForService(x)">Event History</button></form></td>
            </tr>
        </table>
    </div>

    <div ng-show="isMode('eventsForService')">
        <h1>Event History</h1>
        <table>
            <tr ng-repeat="x in eventsForService | orderBy:'timestamp'">
                <td>{{x.timestamp}}</td>
                <td>{{x.type}}</td>
                <td>{{x.value}}</td>
            </tr>
        </table>
    </div>

</div>


<script>

    var container, stats;
    var camera, controls, scene, renderer;
    var pickingData = [], pickingTexture, pickingScene;
    var objects = [];
    var highlightBox;

    var mouse = new THREE.Vector2();
    var offset = new THREE.Vector3(10, 10, 10);

    initThreeJs();
    animateThreeJs();

    // based on 'interactive / cubes / gpu' WebGL example
    function initThreeJs() {
        container=document.getElementById("container");
        camera=new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z=1000;

        controls = new THREE.TrackballControls(camera);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        scene = new THREE.Scene();

        pickingScene = new THREE.Scene();
        pickingTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        pickingTexture.texture.minFilter = THREE.LinearFilter;

        scene.add(new THREE.AmbientLight(0x555555));
        var light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(0, 500, 2000);
        scene.add(light);

        var geometry = new THREE.Geometry();
        var pickingGeometry = new THREE.Geometry();
        var pickingMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );
        var defaultMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors, shininess: 0 });

        function applyVertexColors(g,c) {
            g.faces.forEach(function(f) {
                var n = (f instanceof THREE.Face3) ? 3 : 4;
                for (var j=0;j<n;j++) {
                    f.vertexColors[j]=c;
                }
            });
        }

        var geom = new THREE.BoxGeometry(1,1,1);
        var color = new THREE.Color();

        var matrix=new THREE.Matrix4();
        var quaternion= new THREE.Quaternion();

        for (var i=0;i<5000;i++) {
            var position = new THREE.Vector3();
            position.x=Math.random()*10000 - 5000;
            position.y=Math.random()*6000 - 3000;
            position.z=Math.random()*8000 - 4000;

            var rotation = new THREE.Euler();
            rotation.x=Math.random() * 2 * Math.PI;
            rotation.y=Math.random() * 2 * Math.PI;
            rotation.z=Math.random() * 2 * Math.PI;

            var scale = new THREE.Vector3();
            scale.x=Math.random()*200+100;
            scale.y=Math.random()*200+100;
            scale.z=Math.random()*200+100;

            quaternion.setFromEuler(rotation, false);
            matrix.compose(position, quaternion, scale);

            applyVertexColors(geom, color.setHex(Math.random() * 0xffffff));
            geometry.merge(geom, matrix);

            applyVertexColors(geom, color.setHex(i));
            pickingGeometry.merge(geom, matrix);

            pickingData[i] = { position: position, rotation: rotation, scale: scale };
        }

        var drawnObject = new THREE.Mesh(geometry, defaultMaterial);
        scene.add(drawnObject);

        pickingScene.add(new THREE.Mesh(pickingGeometry, pickingMaterial));
        highlightBox = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshLambertMaterial( { color: 0xffff00 }));
        scene.add(highlightBox);

        renderer=new THREE.WebGLRenderer( { antalias: true });
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects=false;
        container.appendChild(renderer.domElement);

        stats = new Stats();
        container.appendChild(stats.dom);

        renderer.domElement.addEventListener('mousemove', onMouseMove);
    }

    function onMouseMove(e) {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    }

    function animateThreeJs() {
        requestAnimationFrame(animateThreeJs);
        render();
        stats.update();
    }

    function pick() {
        renderer.render(pickingScene, camera, pickingTexture);
        var pixelBuffer = new Uint8Array(4);
        renderer.readRenderTargetPixels(pickingTexture, mouse.x, pickingTexture.height-mouse.y, 1, 1, pixelBuffer);
        var id = (pixelBuffer[0] << 16) | (pixelBuffer[1] << 8) | (pixelBuffer[2]);
        var data = pickingData[id];

        if (data) {
            if (data.position && data.rotation && data.scale) {
                highlightBox.position.copy(data.position);
                highlightBox.rotation.copy(data.rotation);
                highlightBox.scale.copy(data.scale).add(offset);
                highlightBox.visible=true;
            }
        } else {
            highlightBox.visible=false;
        }
    }

    function render() {
        controls.update();
        pick();
        renderer.render(scene, camera);
    }

    var app = angular.module('myApp', []);
    app.controller('myCtrl', function($scope, $http, $location, $interval) {

        $scope.serverUrl = "http://" + $location.host() + ":" + $location.port();

        //  $scope.serverUrl="http://h01u03.int.janelia.org:8180";

        $scope.mode="initialize";

        $scope.isMode = function(m) {
            if ($scope.mode == m) {
                return true;
            }
            return false;
        }

        $scope.switchToMode = function(m) {
            $scope.mode=m;
        }

        $scope.stateCount=0;
        $scope.retrieveOn=false;

        $scope.modeStateSummary = function () {
            $scope.retrieveOn=true;
            $scope.mode="stateSummary";
        }

        $scope.getStateSummary = function() {
            if ($scope.retrieveOn==true) {
                $scope.stateCount = $scope.stateCount + 1;
                $http.get($scope.serverUrl + "/rest-v1/jacsv2/stateSummary")
                    .then(function (response) {
                        $scope.stateSummary = response.data;
                    });
            }
        }

        $scope.getCurrentServices = function() {
            $http.get($scope.serverUrl+"/rest-v1/jacsv2/currentServices")
                .then(function(response) {
                    $scope.currentServices = response.data;
                    $scope.retrieveOn=false;
                    $scope.mode="currentServices";
                });
        }

        $scope.getEventsForService = function(x) {
            $scope.eventsForService=x.events;
            $scope.retrieveOn=false;
            $scope.mode="eventsForService";
        }

        var intervalFunction;
        intervalFunction=$interval( $scope.getStateSummary, 1000);

        // $scope.getStateSummary();

    });
</script>

</body>
</html>
