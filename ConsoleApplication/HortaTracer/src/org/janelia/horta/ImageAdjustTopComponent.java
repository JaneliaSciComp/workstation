/*
 * Licensed under the Janelia Farm Research Campus Software Copyright 1.1
 * 
 * Copyright (c) 2014, Howard Hughes Medical Institute, All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 * 
 *     1. Redistributions of source code must retain the above copyright notice, 
 *        this list of conditions and the following disclaimer.
 *     2. Redistributions in binary form must reproduce the above copyright 
 *        notice, this list of conditions and the following disclaimer in the 
 *        documentation and/or other materials provided with the distribution.
 *     3. Neither the name of the Howard Hughes Medical Institute nor the names 
 *        of its contributors may be used to endorse or promote products derived 
 *        from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, ANY 
 * IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * REASONABLE ROYALTIES; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.janelia.horta;

import org.janelia.geometry3d.BrightnessModel;
import java.util.Collection;
import java.util.Observable;
import java.util.Observer;
import java.util.Timer;
import java.util.TimerTask;
import javax.swing.JComponent;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.util.Lookup;
import org.openide.util.LookupEvent;
import org.openide.util.LookupListener;
import org.openide.windows.TopComponent;
import org.openide.util.NbBundle.Messages;
import org.openide.util.Utilities;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//org.janelia.horta//ImageAdjust//EN",
        autostore = false
)
@TopComponent.Description(
        preferredID = "ImageAdjustTopComponent",
        iconBase = "org/janelia/horta/1404592974_adjust.png",
        persistenceType = TopComponent.PERSISTENCE_ALWAYS
)
@TopComponent.Registration(mode = "output", openAtStartup = false)
@ActionID(category = "Window", id = "org.janelia.horta.ImageAdjustTopComponent")
@ActionReference(path = "Menu/Window/Horta" , position = 50)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_ImageAdjustAction",
        preferredID = "ImageAdjustTopComponent"
)
@Messages({
    "CTL_ImageAdjustAction=Brightness",
    "CTL_ImageAdjustTopComponent=Brightness",
    "HINT_ImageAdjustTopComponent=Controls for adjusting brightness, contrast, color"
})
public final class ImageAdjustTopComponent extends TopComponent 
implements LookupListener
{
    private Lookup.Result<BrightnessModel> colorMapResult = null;
    private BrightnessModel selectedColorMap = null;
    private Observer colorMapObserver;

    public ImageAdjustTopComponent() {
        initComponents();
        setName(Bundle.CTL_ImageAdjustTopComponent());
        setToolTipText(Bundle.HINT_ImageAdjustTopComponent());

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {
        bindingGroup = new org.jdesktop.beansbinding.BindingGroup();

        minSlider = new javax.swing.JSlider();
        maxSlider = new javax.swing.JSlider();
        jLabel1 = new javax.swing.JLabel();
        minSpinner = new javax.swing.JSpinner();
        jLabel2 = new javax.swing.JLabel();
        maxSpinner = new javax.swing.JSpinner();

        minSlider.setMajorTickSpacing(16384);
        minSlider.setMaximum(65535);
        minSlider.setMinorTickSpacing(100);
        minSlider.setToolTipText(org.openide.util.NbBundle.getMessage(ImageAdjustTopComponent.class, "ImageAdjustTopComponent.minSlider.toolTipText")); // NOI18N
        minSlider.setValue(0);
        minSlider.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                minSliderStateChanged(evt);
            }
        });

        maxSlider.setMajorTickSpacing(16384);
        maxSlider.setMaximum(65535);
        maxSlider.setMinorTickSpacing(4096);
        maxSlider.setToolTipText(org.openide.util.NbBundle.getMessage(ImageAdjustTopComponent.class, "ImageAdjustTopComponent.maxSlider.toolTipText")); // NOI18N
        maxSlider.setValue(65535);
        maxSlider.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                maxSliderStateChanged(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(ImageAdjustTopComponent.class, "ImageAdjustTopComponent.jLabel1.text")); // NOI18N

        minSpinner.setModel(new javax.swing.SpinnerNumberModel(0, 0, 65534, 1));

        org.jdesktop.beansbinding.Binding binding = org.jdesktop.beansbinding.Bindings.createAutoBinding(org.jdesktop.beansbinding.AutoBinding.UpdateStrategy.READ_WRITE, minSlider, org.jdesktop.beansbinding.ELProperty.create("${value}"), minSpinner, org.jdesktop.beansbinding.BeanProperty.create("value"));
        bindingGroup.addBinding(binding);

        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(ImageAdjustTopComponent.class, "ImageAdjustTopComponent.jLabel2.text")); // NOI18N

        maxSpinner.setModel(new javax.swing.SpinnerNumberModel(65535, 1, 65535, 1));

        binding = org.jdesktop.beansbinding.Bindings.createAutoBinding(org.jdesktop.beansbinding.AutoBinding.UpdateStrategy.READ_WRITE, maxSlider, org.jdesktop.beansbinding.ELProperty.create("${value}"), maxSpinner, org.jdesktop.beansbinding.BeanProperty.create("value"));
        bindingGroup.addBinding(binding);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(minSlider, javax.swing.GroupLayout.DEFAULT_SIZE, 412, Short.MAX_VALUE)
                    .addComponent(maxSlider, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(minSpinner)
                        .addGap(18, 18, 18)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(maxSpinner)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(minSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2)
                    .addComponent(maxSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(minSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(maxSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(63, Short.MAX_VALUE))
        );

        bindingGroup.bind();
    }// </editor-fold>//GEN-END:initComponents

    private void minSliderStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_minSliderStateChanged
        // Keep max value above min value
        if (minSlider.getValue() >= maxSlider.getValue())
            // maxSlider.setValue(minSlider.getValue() + 1); // push other slider OR...
            minSlider.setValue(maxSlider.getValue() - 1); // ...halt progress of this slider
        else
            updateColorMapProperties();
    }//GEN-LAST:event_minSliderStateChanged

    private void maxSliderStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_maxSliderStateChanged
        // Keep max value above min value
        if (maxSlider.getValue() <= minSlider.getValue())
            // minSlider.setValue(maxSlider.getValue() - 1); // push other slider OR...
            maxSlider.setValue(minSlider.getValue() + 1); // ...halt progress of this slider
        updateColorMapProperties();
    }//GEN-LAST:event_maxSliderStateChanged

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JSlider maxSlider;
    private javax.swing.JSpinner maxSpinner;
    private javax.swing.JSlider minSlider;
    private javax.swing.JSpinner minSpinner;
    private org.jdesktop.beansbinding.BindingGroup bindingGroup;
    // End of variables declaration//GEN-END:variables
    @Override
    public void componentOpened() {
        colorMapResult = Utilities.actionsGlobalContext().lookupResult(BrightnessModel.class);
        colorMapResult.addLookupListener(this);
        Collection<? extends BrightnessModel> allColorMaps = colorMapResult.allInstances();
        if (allColorMaps.isEmpty()) {
            setColorMap(null);
        }
        else {
            setColorMap(allColorMaps.iterator().next());
        }
        throttledUpdateControllerFields();
    }

    @Override
    public void componentClosed() {
        colorMapResult.removeLookupListener(this);
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }

    @Override
    public void resultChanged(LookupEvent le) {
        Collection<? extends BrightnessModel> allColorMapls = colorMapResult.allInstances();
        if (allColorMapls.isEmpty()) {
            setColorMap(null);
            return;
        }
        setColorMap(allColorMapls.iterator().next());
    }
    
    private void setColorMap(BrightnessModel colorMap) {
        if (selectedColorMap == colorMap)
            return; // no change
        if (colorMap == null)
            return; // Remember old colorMap, even when view window focus is lost
        deregisterColorMap(selectedColorMap);
        registerColorMap(colorMap);
    }
    
    private void deregisterColorMap(BrightnessModel colorMap) {
        if (colorMap == null)
            return;
        colorMap.deleteObserver(colorMapObserver);
    }

    private void registerColorMap(BrightnessModel colorMap) {
        selectedColorMap = colorMap;
        if (colorMap == null)
            return;
        if (colorMapObserver == null) {
            colorMapObserver = new Observer() {
                @Override
                public void update(Observable o, Object arg) {
                    throttledUpdateControllerFields();
                }
            };
        }
        colorMap.addObserver(colorMapObserver);
        throttledUpdateControllerFields();
    }

    // For better user interaction, throttle updates to GUI parameter fields
    private Timer fieldUpdateTimer;
    private long previousUpdateTime = System.nanoTime();
    private void throttledUpdateControllerFields()
    {
        // Make this number larger if the GL animation gets too jerky when 
        // the camera control widget is shown
        final int minMilliseconds = 100;
        
        // cancel any previous queued updates
        if (fieldUpdateTimer != null)
            fieldUpdateTimer.cancel();

        long now = System.nanoTime();

        long remaining = minMilliseconds - (now - previousUpdateTime)/1000000;
        
        // It's been a long time, so update now
        if ( remaining <= 0 ) {
            // System.out.println("throttled update");
            immediateUpdateControllerFields();
        }
        
        else {
            // System.out.println("throttle stop!");
            fieldUpdateTimer = new Timer();
            fieldUpdateTimer.schedule(new TimerTask() 
            {
                @Override
                public void run() {
                    immediateUpdateControllerFields();
                }
            }, remaining);
            return;
        }
        
        previousUpdateTime = now;
    }
    
    private boolean doUpdateColorMap = true;
    private final JComponent[] widgets = new JComponent[] {
        minSlider,
        maxSlider
    };

    // This method make GL updates lag if called directly too often
    private void immediateUpdateControllerFields()
    {
        try { // I saw a NPE in here once in the client viewer...
            // turn off listener
            doUpdateColorMap = false;

            if (selectedColorMap == null) {
                minSlider.setValue(minSlider.getMinimum());
                maxSlider.setValue(maxSlider.getMaximum());
                // Gray out tools not connected to a BrightnessModel
                for (JComponent w : widgets)
                    if (w != null) w.setEnabled(false);
            }
            else {
                // Ungray controls for live BrightnessModel
                for (JComponent w : widgets)
                    if (w != null) w.setEnabled(true);

                // We use doUpdateColorMap flag to avoid race condition.
                minSlider.setValue((int)(selectedColorMap.getMinimum() * minSlider.getMaximum())); // saw NPE here...
                maxSlider.setValue((int)(selectedColorMap.getMaximum() * minSlider.getMaximum()));
            }
        }
        catch (Exception ex) {
            ex.printStackTrace();
        }
        finally {
            // Turn listeners back on
            doUpdateColorMap = true;
        }
    }
    
    private void updateColorMapProperties() {
        if (! doUpdateColorMap)
            return;
        if (selectedColorMap == null)
            return;
        BrightnessModel colorMap = new BrightnessModel(selectedColorMap);
        colorMap.setMinimum(minSlider.getValue() / (float)minSlider.getMaximum());
        colorMap.setMaximum(maxSlider.getValue() / (float)maxSlider.getMaximum());
        selectedColorMap.copy(colorMap);
        selectedColorMap.notifyObservers();
    }

}
